%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Node: autonomy
%
% Purpose:
% The purpose of the autonomy node is to generate, monitor, and manipulate
% a queue of behaviors that define mission and safety objectives. The
% behaviors are initially specified in a mission configuration file that is
% read by the autonomy node at the start of a run. Each behavior is used to
% accomplish a specific task by generating appropriate 'ahsCommands' of
% [altitude, heading, forward speed, crab speed] to be used as setpoints
% by the control node. A single behavior might only generate a subset of
% such commands. The functionality of each behavior will be encapsulated in
% a .m file with the prefix: BHV_ .
%
% Examples of mission behaviors include:
%   - BHV_Takeofff
%   - BHV_ConstantAltitude
%   - BHV_ConstantHeadingSpeed
%   - BHV_PositionHold
%   - BHV_Land
%   - BHV_FollowWpts
%   - BHV_KeepTargetCentered
%
% Examples of safety behaviors include:
%   - BHV_LowBatteryLanding
%   - BHV_OpRegion
%   - BHV_AvoidObstacle
%
% A behavior manager will monitor the progress of each behavior. When the
% behavior (or set of behaviors) indicate they are 'complete' they will
% become inactive and the next set of behaviros in the mission will become
% active. Safety behaviors will be used to over-ride existing mission
% behaviors in emergency situations.
%
% The autonomy node may also perform some other relevant services such as
% path planning.
%
% Input:
%   - ROS topic: /stateEstimate (generated by estimation)
%   - ROS topic: /features (generated by vision)
%
% Output:
%   - ROS topic: /ahsCmd (used by control)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% prepare workspace
clear; close all; clc; format compact;
addpath('../')
params = loadParams();

% missions
mission = loadMission(); % hover test
%mission = loadMissionAltModeTest(); %hover test 

fprintf('Launching Autonomy Node...\n');

global timestamps

% initialize ROS
if(~robotics.ros.internal.Global.isNodeActive)
    rosinit;
end

% Subscribers
stateEstimateSubscriber = rossubscriber('/stateEstimate');
startMissionSubscriber = rossubscriber('/startMission', 'std_msgs/Bool');
% yawErrorCameraSubscriber = rossubscriber('/yawSetpoint');
% targetDetectionFlagSubscriber = rossubscriber('/targetFlag', 'std_msgs/Bool');

% Publishers
ayprCmdPublisher = rospublisher('/ayprCmd', 'terpcopter_msgs/ayprCmd');
pause(0.1)

% Unpacking Initial ROS Messages
[ayprCmdMsg] = default_aypr_msg(ayprCmdPublisher);

% initial variables
stick_thrust = -1;

r = robotics.Rate(10);
reset(r);

if ( strcmp(params.auto.mode,'auto'))
    send(ayprCmdPublisher, ayprCmdMsg);
    
    % This enables the capability to start the mission through the TunerGUI
    startMissionFlag = false;
    startMissionMsg = receive(startMissionSubscriber);
    startMissionFlag = startMissionMsg.Data;
    
    while(1)
        
        % get latest messages
        stateEstimateMsg = stateEstimateSubscriber.LatestMessage;
        %         yawErrorCameraMsg = yawErrorCameraSubscriber.LatestMessage;
        %         targetDetectionFlagMsg = targetDetectionFlagSubscriber.LatestMessage;
        
        % unpack statestimate
        t = stateEstimateMsg.Time;
        z = stateEstimateMsg.Up;
        fprintf('Received Msg, Quad Alttiude is : %3.3f m\n', z );
        
        % first behavior in mission is always the active/current one
        currentBehavior = 1;        
        
        % initialize and time-stamps on first-loop iteration
        if mission.config.firstLoop == 1
            disp('Behavior Manager Started')
            % initialize time variables
            timestamps.initial_event_time = t;
            timestamps.behavior_switched_timestamp = t;
            timestamps.behavior_satisfied_timestamp = t;
            mission.config.firstLoop = false; % ends the first loop
        end
        
        % Logic for the Target Detection
        %%%%%%%%%%%%%%
        %         if (targetDetectionFlagMsg.Data && behavior.bhv{1}.initialDetection == true)
        %             fprintf(' Detected Target Flag');
        %             [mission.bhv] = push(mission.bhv, behavior.bhv{1});
        %             behavior.bhv{1}.initialDetection = false;
        %         end
        %%%%%%%%%%%%%%
        
        % extract 
        name = mission.bhv{currentBehavior}.name;
        flag = mission.bhv{currentBehavior}.completion.status;
        aypr = mission.bhv{currentBehavior}.aypr;
        completion = mission.bhv{currentBehavior}.completion;
        
        totalTime = t - timestamps.initial_event_time;
        bhvTime = t - timestamps.behavior_switched_timestamp;
        
        fprintf('Current Behavior: %s\tTime Spent in Behavior: %f\t Total Time of Mission: %f \n\n',name,bhvTime,totalTime);
        
        % if behavior completes pop behavior
        if flag == true
            [mission.bhv] = pop(mission.bhv, t);
        else
            % check status of remaining behavior
            %Set Handles within each behavior
            switch name
                case 'bhv_takeoff'
                    [completionFlag, stick_thrust] = bhv_takeoff_status(stateEstimateMsg, aypr, stick_thrust);
                case 'bhv_hover'
                    [completionFlag] = bhv_hover_status(stateEstimateMsg, aypr, completion, t);
                    ayprCmdMsg.AltitudeMeters = mission.bhv{currentBehavior}.ahs.desiredAltMeters;
                case 'bhv_point_to_direction'
                    [completionFlag] = bhv_point_to_direction_status(stateEstimateMsg, aypr, completion, t);
                case 'bhv_land'
                    init = mission.bhv{currentBehavior}.initialize;
                    [completionFlag, initialize, ahsUpdate] = bhv_landing_status(stateEstimateMsg, aypr, completion, t, init);
                    display(initialize)
                    mission.bhv{currentBehavior}.initialize.firstLoop = initialize;
                    ayprCmdMsg.AltitudeMeters = ahsUpdate;
%                 case 'bhv_land_open'
%                     [completionFlag, stick_thrust_land] = bhv_landing_open_status(stateEstimateMsg, aypr, completion);
%                     openLoopIsActiveMsg.Data = true;      % true: openloop control
%                     closedLoopIsActiveMsg.Data = false;
%                     openLoopStickCmdMsg.Thrust = stick_thrust_land;
%                 case 'bhv_point_to_target'
%                     [completionFlag] = bhv_point_to_target_status(stateEstimateMsg, yawErrorCameraMsg, aypr, completion, t);
%                     ayprCmdMsg.HeadingRad = yawErrorCameraMsg.Data;
                otherwise
            end
            mission.bhv{currentBehavior}.completion.status = completionFlag;
        end
        
        % publish
        send(ayprCmdPublisher, ayprCmdMsg);
        fprintf('Published Ahs Cmd. Alt : %3.3f \t Yaw: %3.3f\n', ayprCmdMsg.AltitudeMeters, ayprCmdMsg.HeadingRad);        
        waitfor(r);
    end
end
% 
%     if ( strcmp(params.auto.mode, 'manual'))
%     fprintf('Autonomy Mode: Manual');
% 
%     send(openLoopIsActivePublisher, openLoopIsActiveMsg);
%     send(closedLoopIsActivePublisher, closedLoopIsActiveMsg);
% 
%     send(pidAltSettingPublisher, pidAltSettingMsg);
%     send(pidYawSettingPublisher, pidYawSettingMsg);
%     send(ahsCmdPublisher, ayprCmdMsg);
%     send(openLoopIsActivePublisher, openLoopIsActiveMsg);
%     send(closedLoopIsActivePublisher, closedLoopIsActiveMsg);
%     
%     while(1)
%         waitfor(r);
%     end
% end
