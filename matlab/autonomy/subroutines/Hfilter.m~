function [pxFilt, pyFilt] = Hfilter(stateEstimateMsg, bhvTime, hDetected, hAngle, hPixelX, hPixelY, logname, axRaw, ayRaw)

% hDetected = 0 (no H detected) , 1 (H detected)
% hAngle = -180 to 180 (deg)
% hPixelX = -360 to 360 (pixels)
% hPixelY = -640 to 640

% process noise
stdev_pos = 1;% m
stdev_vel = 0.1;% m/s
stdev_accel = 0.1;% m/s^2

% measurement noise
stdev_pixel_meas = 2;% pixels
stdev_accel_meas = 0.1;% pixels

% camera model
kcam = 1/100; % meters/pixel (at a fixed altitude)

% outlier rejection
Raccept = 150; % pixels

% initial filter conditions
Pinit = diag([stdev_pos^2 stdev_pos^2 stdev_vel^2 stdev_vel^2 stdev_accel^2 stdev_accel^2]); % 6 x 6
xinit = [0 0 0 0 0 0]';

% derived parameter
% z = [x y vx vy ax ay];
Q = diag([stdev_pos^2 stdev_pos^2 stdev_vel^2 stdev_vel^2 stdev_accel^2 stdev_accel^2]); % 6 x 6
R_det = diag([stdev_pixel^2 stdev_pixel^2 stdev_accel^2 stdev_accel^2]); % 4 x 4
R_no_det = diag([stdev_pixel^2 stdev_pixel^2 stdev_accel^2 stdev_accel^2]);% 4 x 4

% initialize
persistent lastTime xkm1_km1 Pkm1_km1 lastValidTime lastHrefYawDeg lastPixelX lastPixelY lastHangle;

% unpack state estimate
% pitch = stateEstimateMsg.PitchDegrees;
% roll = stateEstimateMsg.RollDegrees;
currentYawDeg = stateEstimateMsg.YawDegrees;

if isempty(xkm1_km1)
    xkm1_km1 = xinit;
    Pkm1_km1 = Pinit;
end

% compute time step
T = bhvTime - lastTime;

% z = [x y vx vy ax ay bx by];
S = T^2/2;
F = [1 0 T 0 S 0;
    0 1 0 T 0 S;
    0 0 1 0 T 0;
    0 0 0 1 0 T;
    0 0 0 0 0 0;
    0 0 0 0 0 0];
G = 0;
ukm1 = 0;
H_det = [1 0 0 0 0 0;
    0 1 0 0 0 0;
    0 0 0 0 1 0;
    0 0 0 0 0 1];
H_no_det = [0 0 0 0 0 0;
    0 0 0 0 0 0;
    0 0 0 0 1 0;
    0 0 0 0 0 1];

% check if measurement passes through gate 
gateSatisfied = 0;
if ( hDetected )
    % get H-relative heading, th
    th =  currentYawDeg + hAngle;
    vLast = [lastPixelX lastPixelY];
    vNew = [hPixelX hPixelY];
    % check if measurement is consistent with last measurement
    if ( norm(vLast-vNew) <= Raccept ) 
        % check if measurement is unique
        if ( any([lastPixelX lastPixelY lastHangle]==[hPixelX hPixelY hAngle]) )
            
            
        if ( lastPixelX == )
        gateSatisfied = 1;
    end
end

% compute rotation matrix
if ( gateSatisfied ) 
   th = hAngle;
else        
   th = signedAngularDist(currentYawDeg, lastHrefYawDeg) + 90;
end
R = [cos(th) -sin(th); cos(th) sin(th)];

% rotate accelerations
a = R*[axFilt ayFilt]';
ax = a(1);
ay = a(2);

%filter
if ( gateSatisfied )
    
    % rotate pixels
    p = R*[hPixelX hPixelY]';
    px = p(1);
    py = p(2);
    
    % convert pixels to x,y (measured)
    xm = kcam*px;
    ym = kcam*py;
    
    % package measurement
    yk = [xm ym ax ay]';
    
    % filter with pixel measurement
    [xk_k, Pk_k, K, xk_km1, Pk_km1] = discreteKalmanFilter(xkm1_km1, ukm1, Pkm1_km1, yk, F, G, H_det, Q, R_det);
    
    % update last valid
    lastValidTime = bhvTime;
    lastPixelX = hPixelX;
    lastPixelY = hPixelY;
    lastHangle = hAngle;
    lastHrefYawDeg = currentYawDeg - (hAngle - 90);
else
    % package measurement
    yk = [ax ay]';
    
    % filter without pixel measurement
    [xk_k, Pk_k, K, xk_km1, Pk_km1] = discreteKalmanFilter(xkm1_km1, ukm1, Pkm1_km1, yk, F, G, H_no_det, Q, R_no_det);
end

% update persistent
xkm1_km1 = xk_k;
Pkm1_km1 = Pk_k;
lastTime = bhvTime;

% rotate back body frame
pFilt = R'*[xk_k(1) xk_k(2)]'./kcam;

% output pixels
pxFilt = pFilt(1);
pyFilt = pFilt(2);

% logging
logFlag = 1;
if ( logFlag )
    
    pFile = fopen( logname ,'a');
    
    % write csv file
    fprintf(pFile,'%6.6f,',curTime);
    fprintf(pFile,'%6.6f,',dt);
    fprintf(pFile,'%6.6f,',zd);
    fprintf(pFile,'%6.6f,',zcur);
    fprintf(pFile,'%6.6f,',altFilt);
    fprintf(pFile,'%6.6f,',altRateCmd);

    % constant parameters
    fprintf(pFile,'%6.6f,',altFiltTimeConstant);
    fprintf(pFile,'%6.6f,',climbRateCmd);
    fprintf(pFile,'%6.6f,',descentRateCmd);
    fprintf(pFile,'%6.6f,\n',setpointDeadband);

    fclose(pFile);    
end


end


