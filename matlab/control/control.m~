%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Node: control
%
% Purpose:
% The purpose of the control node is to regulate the quadcopter to desired
% setpoints of [altitude, heading, forward speed, crab speed]. We refer to
% this as a 'ahsCmd' which is generated by a behavior in the autonomy node.
% The control node determines the appropriate 'stickCmd' [yaw, pitch, roll,
% thrust] to send to the virtual_transmitter.
%
% Input:
%   - ROS topic: /stateEstimate (generated by estimation)
%   - ROS topic: /ahsCmd (generated by autonomy)
%
% Output:
%   - ROS topic: /stickCmd (used by virtual_transmitter)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% prepare workspace
clear; close all; clc; format compact;
addpath('../')
params = loadParams();

global controlParams
controlParams = params.ctrl;
fprintf('Control Node Launching...\n');

% initialize ROS
if(~robotics.ros.internal.Global.isNodeActive)
    rosinit;
end

% Subscribers
stateEstimateSubscriber = rossubscriber('/stateEstimate');
openLoopIsActiveSubscriber = rossubscriber('/openLoopIsActive', 'std_msgs/Bool');
closedLoopIsActiveSubscriber = rossubscriber('/closedLoopIsActive', 'std_msgs/Bool');
ahsCmdSubscriber = rossubscriber('/ahsCmd');
startMissionSubscriber = rossubscriber('/startMission', 'std_msgs/Bool');
%yawSetpointSubscriber = rossubscriber('/yawSetpoint');
pidAltSettingSubscriber = rossubscriber('/pidAltSetting');
%pidResetSubscriber = rossubscriber('/pidReset');
pidYawSettingSubscriber = rossubscriber('/pidYawSetting', 'terpcopter_msgs/ffpidSetting');
openLoopStickCmdSubscriber = rossubscriber('/openLoopStickCmd', 'terpcopter_msgs/openLoopStickCmd');

% Publishers
%pidResetPublisher = rospublisher('/pidReset', 'std_msgs/Bool');
stickCmdPublisher = rospublisher('/stickCmd', 'terpcopter_msgs/stickCmd');
altControlDegbugPublisher = rospublisher('/altControlDebug','terpcopter_msgs/altControlDebug');

% % grab latest messages
stateEstimateMsg = stateEstimateSubscriber.LatestMessage;
ahsCmdMsg = ahsCmdSubscriber.LatestMessage;
pidAltSettingMsg = pidAltSettingSubscriber.LatestMessage;
% pidYawSettingMsg = pidYawSettingSubscriber.LatestMessage;
% yawSetpointMsg = yawSetpointSubscriber.LatestMessage;

% timestamp
ti = rostime('now');
t0 = [];
abs_t = double(ti.Sec)+double(ti.Nsec)*10^-9;
if isempty(t0), t0 = abs_t; end

% initialize messages to publish
stickCmdMsg = rosmessage(stickCmdPublisher);
stickCmdMsg.Thrust = -1;
stickCmdMsg.Yaw = 0;

% initialize altiude control gains / constants
altControl.altFiltTimeConstant = 0.1; % sec, used to filter lidar
altControl.climbRateCmd = 0.27; % nominal stick position for climb [-1,1]
altControl.descentRateCmd = -0.23; % nominal stick position for climb [-1,1]
altControl.altErrorDeadband = 0.05; % meters, deadband around desired altitude
altControl.settlingTime = 1E3; % sec, waits this amount of time after setpoint issued to give climb or descent (if deadband excedded)
altControl.log=[params.env.matlabRoot '/altControl_' datestr(now,'mmmm_dd_yyyy_HH_MM_SS_FFF') '.log'];

% initialize altitude controller state
altControl.lastTime = 0;
altControl.prevAlt = 0;
altControl.setpointReached = 0;
altControl.setpointVal = 0;

% initialize pitch and roll controller gains / constants
pitchRollLogName =[params.env.matlabRoot '/prControl_' datestr(now,'mmmm_dd_yyyy_HH_MM_SS_FFF') '.log'];
pause(2)

% set loop rate and initialize
disp('initialize loop');
r = robotics.Rate(90);
reset(r);
send(stickCmdPublisher, stickCmdMsg); % send initial stick command.

while(1)
    
    % get latest messages
    stateEstimateMsg = stateEstimateSubscriber.LatestMessage;
    ahsCmdMsg = ahsCmdSubscriber.LatestMessage;
    pidAltSettingMsg = pidAltSettingSubscriber.LatestMessage;
    pidYawSettingMsg = pidYawSettingSubscriber.LatestMessage;
    openLoopStickCmdMsg = openLoopStickCmdSubscriber.LatestMessage;
    openLoopIsActiveMsg = openLoopIsActiveSubscriber.LatestMessage;
    startMissionMsg = startMissionSubscriber.LatestMessage;
    closedLoopIsActiveMsg = closedLoopIsActiveSubscriber.LatestMessage;
    % yawSetpointMsg = yawSetpointSubscriber.LatestMessage;
    
    % unpack state estimate
    absolutePitch = stateEstimateMsg.Pitch;
    absoluteRoll = stateEstimateMsg.Roll;
    z = stateEstimateMsg.Range;
    yaw = stateEstimateMsg.Yaw;
    
    % timestamp
    ti= rostime('now');
    abs_t = double(ti.Sec)+double(ti.Nsec)*10^-9;
    t = abs_t-t0;
    
    % unpack altitude, heading, speed command
    z_d = ahsCmdMsg.AltitudeMeters;
    
    yaw_d = ahsCmdMsg.HeadingRad; %yawSetpointMsg.Data; % ;
    
    
    
    %         New Yaw Controller
    %yaw_d = deg2rad(yaw_d);
    %yaw = deg2rad(yaw);
    yawError = yaw_d;%(yaw_d - yaw);
    yawError = (atan2(sin(yawError),cos(yawError)));
    disp('yawError')
    disp(yawError)
    
    disp('yawSetpointError')
    %               disp(yaw_error)
    
    u_t_yaw = pidYawSettingMsg.Kp*yawError;
    % compute control
    %        [u_t_alt, altControl] = altModeController(altControl, t, z, z_d);
    
    %        disp(u_t_alt)
    
    
    %Pitch Control
    PitchError = Pitch_d - absolutePitch;
    u_t_pitch = 0.1*PitchError;
    
    %Roll COntrol
    RollError = Roll_d - absoluteRoll;
    u_t_roll = 0.1*RollError
    
    
    pFile = fopen(pitchRollLogName,'a');
    
    % write csv file
    fprintf(pFile,'%3.3f,',t);
    fprintf(pFile,'%3.3f,',Pitch_d);
    fprintf(pFile,'%3.3f,',absolutePitch);
    fprintf(pFile,'%3.3f,',PitchError);
    fprintf(pFile,'%3.3f,',u_t_pitch);
    fprintf(pFile,'%3.3f,',Roll_d);
    fprintf(pFile,'%3.3f,',absoluteRoll);
    fprintf(pFile,'%3.3f\n',RollError);
    fprintf(pFile,'%3.3f,',u_t_roll);
    fclose(pFile);
    
    % publish
    stickCmdMsg.Thrust = 0;
    stickCmdMsg.Yaw = max(-1,min(1,u_t_yaw));
    stickCmdMsg.Pitch = max(-1,min(1,u_t_pitch))*0.5;
    stickCmdMsg.Roll = max(-1,min(1,u_t_roll))*0.5;
    
    % send stick commands
    fprintf('Stick Cmd.Thrust : %3.3f, Altitude : %3.3f, Altitude_SP : %3.3f, Error : %3.3f, Yaw : %3.3f \n', stickCmdMsg.Thrust , stateEstimateMsg.Up, z_d, ( z - z_d ), u_t_yaw );
    send(stickCmdPublisher, stickCmdMsg);
    waitfor(r);
end

