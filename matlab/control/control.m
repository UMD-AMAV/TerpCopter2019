%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Node: control
%
% Purpose:
% The purpose of the control node is to regulate the quadcopter to desired
% setpoints of [altitude, heading, forward speed, crab speed]. We refer to
% this as a 'ahsCmd' which is generated by a behavior in the autonomy node.
% The control node determines the appropriate 'stickCmd' [yaw, pitch, roll,
% thrust] to send to the virtual_transmitter.
%
% Input:
%   - ROS topic: /stateEstimate (generated by estimation)
%   - ROS topic: /ahsCmd (generated by autonomy)
%
% Output:
%   - ROS topic: /stickCmd (used by virtual_transmitter)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% prepare workspace
clear; close all; clc; format compact;
addpath('../')
params = loadParams();

global controlParams
controlParams = params.ctrl;
fprintf('Control Node Launching...\n');

% declare global variables
% Determine usage in other scripts - change to local if no other usage

%
% yawError.lastVal = 0;
% yawError.lastSum = 0;
% yawError.lastTime = 0;


% initialize ROS
if(~robotics.ros.internal.Global.isNodeActive)
    rosinit;
end

% Subscribers
stateEstimateSubscriber = rossubscriber('/stateEstimate');
openLoopIsActiveSubscriber = rossubscriber('/openLoopIsActive', 'std_msgs/Bool');
closedLoopIsActiveSubscriber = rossubscriber('/closedLoopIsActive', 'std_msgs/Bool');
ahsCmdSubscriber = rossubscriber('/ahsCmd');
startMissionSubscriber = rossubscriber('/startMission', 'std_msgs/Bool');
% yawSetpointSubscriber = rossubscriber('/yawSetpoint');
pidAltSettingSubscriber = rossubscriber('/pidAltSetting');
%pidResetSubscriber = rossubscriber('/pidReset');
pidYawSettingSubscriber = rossubscriber('/pidYawSetting', 'terpcopter_msgs/ffpidSetting');
openLoopStickCmdSubscriber = rossubscriber('/openLoopStickCmd', 'terpcopter_msgs/openLoopStickCmd');

% Publishers
%pidResetPublisher = rospublisher('/pidReset', 'std_msgs/Bool');
stickCmdPublisher = rospublisher('/stickCmd', 'terpcopter_msgs/stickCmd');
altControlDegbugPublisher = rospublisher('/altControlDebug','terpcopter_msgs/altControlDebug');

pause(2)

% initialize message to publish
stickCmdMsg = rosmessage(stickCmdPublisher);
stickCmdMsg.Thrust = 0;
stickCmdMsg.Yaw = 0;


% % grab latest messages
% stateEstimateMsg = stateEstimateSubscriber.LatestMessage;
ahsCmdMsg = ahsCmdSubscriber.LatestMessage;
pidAltSettingMsg = pidAltSettingSubscriber.LatestMessage;
% pidYawSettingMsg = pidYawSettingSubscriber.LatestMessage;
% % yawSetpointMsg = yawSetpointSubscriber.LatestMessage;

% manage timestamps
% timeMatrix=[];
ti = rostime('now');
%abs_t = eval([int2str(ti.Sec) '.' ...
%int2str(ti.Nsec)]);
t0 = [];
abs_t = double(ti.Sec)+double(ti.Nsec)*10^-9;
if isempty(t0), t0 = abs_t; end

% initialize error variables
% altitudeErrorHistory.lastTime = 0; %stateEstimateMsg.Time;
% altitudeErrorHistory.lastVal = ahsCmdMsg.AltitudeMeters;
% altitudeErrorHistory.lastSum = 0;
% altitudeErrorHistory.lastError = 0;
% u_t_alt = controlParams.altitudeGains.ffterm;


% initialize
%global altControl;
stateEstimateMsg = stateEstimateSubscriber.LatestMessage;
altControl.time = 0;
altControl.alt = stateEstimateMsg.Range;
altControl.altRate = 0;
altControl.altDesired = stateEstimateMsg.Range;
altControl.altIntegralError = 0;
altControl.log=[params.env.matlabRoot '/altControl_' datestr(now,'mmmm_dd_yyyy_HH_MM_SS_FFF') '.log'];

% yaw controller
% absoluteYaw = stateEstimateMsg.Yaw;
% ahsCmdMsg.HeadingRad = absoluteYaw;
% yawError.lastTime = stateEstimateMsg.Time;
% yawError.lastVal = 0; %ahsCmdMsg.HeadingRad;
% yawError.lastSum = 0;
u_t_yaw = 0;


disp('initialize loop');

% set frequency of ROS update
r = robotics.Rate(100);
reset(r);

send(stickCmdPublisher, stickCmdMsg); % send initial stick command.

while(1)
    % get latest messages
    stateEstimateMsg = stateEstimateSubscriber.LatestMessage;
    ahsCmdMsg = ahsCmdSubscriber.LatestMessage;
    pidAltSettingMsg = pidAltSettingSubscriber.LatestMessage;
    pidYawSettingMsg = pidYawSettingSubscriber.LatestMessage;
    openLoopStickCmdMsg = openLoopStickCmdSubscriber.LatestMessage;
    openLoopIsActiveMsg = openLoopIsActiveSubscriber.LatestMessage;
    startMissionMsg = startMissionSubscriber.LatestMessage;
    closedLoopIsActiveMsg = closedLoopIsActiveSubscriber.LatestMessage;
    %     yawSetpointMsg = yawSetpointSubscriber.LatestMessage;
    
    
    
    if (openLoopIsActiveMsg.Data == true) && (closedLoopIsActiveMsg.Data == false)
        % set stick command directly based on openLoopStickCmd message
        stickCmdMsg.Thrust = openLoopStickCmdMsg.Thrust;
        stickCmdMsg.Yaw = openLoopStickCmdMsg.Yaw;
        stickCmdMsg.Pitch = openLoopStickCmdMsg.Pitch;
        stickCmdMsg.Roll = openLoopStickCmdMsg.Roll;
    elseif (openLoopIsActiveMsg.Data == false) && (closedLoopIsActiveMsg.Data == true)
        
        % timestamp
        ti= rostime('now');
        abs_t = double(ti.Sec)+double(ti.Nsec)*10^-9;
        t = abs_t-t0;
        %timeMatrix = [timeMatrix;t];
        %if isempty(t0), t0 = abs_t; end
        %fprintf("t %6.4f",t);
        
        % unpack statestimate
        %t = stateEstimateMsg.Time;
        z = stateEstimateMsg.Range;
        yaw = stateEstimateMsg.Yaw; % - absoluteYaw;
        
        % get setpoint
        z_d = ahsCmdMsg.AltitudeMeters;
        
        %%%% CAHNGING YAW FROM GUI TO VISION %%%%%
        %     yaw_d = yawSetpointMsg.Data; % ahsCmdMsg.HeadingRad;
                
        % update errors
        altError = z_d - z;
        
%         % reset integral term if boolean (pidResetSubscriber) is true 
%         % this comes from the tuner GUI
%         pidResetMsg = rosmessage('std_msgs/Bool');
%         pidResetMsg.Data = false;
%         pidResetMsg = pidResetSubscriber.LatestMessage;
%         if ~isempty(pidResetMsg)
%             if pidResetMsg.Data == true
%                 disp("Resetting PID ...")
%                 altitudeErrorHistory.lastVal = ahsCmdMsg.AltitudeMeters;
%                 altitudeErrorHistory.lastSum = 0;
%                 pidResetMsg.Data = false;
%                 send(pidResetPublisher, pidResetMsg);
%             end
%         end
        
        % compute controls
        % FF_PID(gains, error, newTime, newErrVal)
        %[u_t_alt, altitudeErrorHistory] = FF_PID(pidAltSettingMsg, altitudeErrorHistory, t, altError);
        
        % hardcode for now
        gains.Kp = 0.050;
        gains.Ki = 0.030;
        gains.Kd = 0.003;
        gains.ffterm = -0.15;

        gains.integralTermLimit = 0.3; % units of thrust cmd [-1, 1]
        gains.saturationLimit = 0.2;
        
        gains.altTimeConstant = 0.3;
        gains.altRateTimeConstant = 0.15;
        gains.altDesTimeConstant = 6.0;

        [u_t_alt, altControl] = altitudeControllerPID(gains, altControl, t, z, z_d, altControlDegbugPublisher);
        
        %New Yaw Controller
        %     yaw_d = deg2rad(yaw_d);
        %     yaw = deg2rad(yaw);
        %     yawError = yaw_d;%(yaw_d - yaw);
        %     yawError = (atan2(sin(yawError),cos(yawError)));
        %     disp('yawError')
        %       disp(yawError)
        
        %       disp('yawSetpointError')
        %       disp(yaw_error)
        
        %     u_t_yaw = -pidYawSettingMsg.Kp*yawError;
        % compute controls
        %      [u_t_yaw, yawError] = PID(pidYawSettingMsg, yawError, t, yaw_error);
        %      disp('yaw control gains');
        %      disp(controlParams.yawGains)
        %      disp('yaw control signal');
        %      disp(u_t_yaw)
        
        
        % publish
        stickCmdMsg.Thrust = u_t_alt; 
        stickCmdMsg.Yaw = max(-1,min(1,u_t_yaw));
        
        % debug/display
        fprintf('Altitude meters : %3.3f [m]\n', z);
        fprintf('Yaw Angle : %3.3f [deg]\n', yaw);        
        disp('pid loop');
        disp(pidAltSettingMsg)
        %     disp('yawSetpoint')
        %     disp(yaw_d)
        disp('yawCurrent')
        disp(yaw)        
        fprintf('Stick Cmd.Thrust : %3.3f, Altitude : %3.3f, Altitude_SP : %3.3f, Error : %3.3f, Yaw : %3.3f \n', stickCmdMsg.Thrust , stateEstimateMsg.Up, z_d, ( z - z_d ), u_t_yaw );
        %fprintf('Iteration: %d - Time Elapsed: %f\n',i,time)
        %time = r.TotalElapsedTime;        
        
    %elseif startMissionMsg.Data == false
    %    fprintf('Mission has not started. Press Start Mission button in Tuner GUI.\n');
    else
        fprintf('Error: both open loop and closed loop control are either running or not running\n');
    end
    send(stickCmdPublisher, stickCmdMsg);
    disp('Controller');
    waitfor(r);
end

