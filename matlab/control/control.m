%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Node: control
%
% Purpose:  
% The purpose of the control node is to regulate the quadcopter to desired
% setpoints of [altitude, heading, forward speed, crab speed]. We refer to
% this as a 'ahsCmd' which is generated by a behavior in the autonomy node.
% The control node determines the appropriate 'stickCmd' [yaw, pitch, roll,
% thrust] to send to the virtual_transmitter.
%
% Input:
%   - ROS topic: /stateEstimate (generated by estimation)
%   - ROS topic: /ahsCmd (generated by autonomy)
%   
% Output:
%   - ROS topic: /stickCmd (used by virtual_transmitter)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% prepare workspace
clear; close all; clc; format compact;
addpath('../')
params = loadParams();

global controlParams
controlParams = params.ctrl;
fprintf('Control Node Launching...\n');

% declare global variables
% Determine usage in other scripts - change to local if no other usage
global altitudeError;
altitudeError.lastVal = 0;
altitudeError.lastSum = 0;
altitudeError.lastTime = 0;

yawError.lastVal = 0;
yawError.lastSum = 0;
yawError.lastTime = 0;

global ahsCmdMsg;
ahsCmdMsg = rosmessage('terpcopter_msgs/ahsCmd');
ahsCmdMsg.AltitudeMeters = 0;
ahsCmdMsg.HeadingRad = 0;
ahsCmdMsg.ForwardSpeedMps = 0;
ahsCmdMsg.CrabSpeedMps = 0;

global stateEstimateMsg;
% initialize  stateEstimate --pending--

% initialize ROS
if(~robotics.ros.internal.Global.isNodeActive)
    rosinit;
end

controlNode = robotics.ros.Node('/control');
stickCmdPublisher = robotics.ros.Publisher(controlNode,'stickCmd','terpcopter_msgs/stickCmd');
stickCmdMsg = rosmessage('terpcopter_msgs/stickCmd');
stickCmdMsg.Thrust = 0;
stickCmdMsg.Yaw = 0;

stateEstimateSubscriber = robotics.ros.Subscriber(controlNode,'stateEstimate','terpcopter_msgs/stateEstimate',{@stateEstimateCallback});
ahsCmdSubscriber = robotics.ros.Subscriber(controlNode,'ahsCmd','terpcopter_msgs/ahsCmd',{@ahsCmdCallback});
pidSettingSubscriber = robotics.ros.Subscriber(controlNode,'pidSetting','terpcopter_msgs/ffpidSetting',{@ffpidSettingCallback});
obPidEnableSubscriber = robotics.ros.Subscriber(controlNode,'stateEstimate','terpcopter_msgs/stateEstimate',{@stateEstimateCallback});


stateEstimateMsg = receive(stateEstimateSubscriber,5);

altitudeError.lastTime = stateEstimateMsg.Time;
altitudeError.lastVal = ahsCmdMsg.AltitudeMeters;
altitudeError.lastSum = 0;
u_t_alt = controlParams.altitudeGains.ffterm;

yawError.lastTime = stateEstimateMsg.Time;
yawError.lastVal = ahsCmdMsg.HeadingRad;
yawError.lastSum = 0;
u_t_yaw = 0;

disp('initialize loop');

r = robotics.Rate(10);
reset(r);

send(stickCmdPublisher, stickCmdMsg);

while(1)
    

    % unpack statestimate
    t = stateEstimateMsg.Time;
    z = stateEstimateMsg.Range;
    yaw = stateEstimateMsg.Yaw;
    fprintf('Current Quad Alttiude is : %3.3f m\n', z );

    % get setpoint
    z_d = ahsCmdMsg.AltitudeMeters;
    yaw_d = ahsCmdMsg.HeadingRad;
    
    % update errors
    altSetpointError = z - z_d;
    
    if (abs(yaw-yaw_d) >= abs(yaw_d-yaw))
        yawSetpointError = yaw - yaw_d;
    else 
        yawSetpointError = yaw_d - yaw;
    end


    % compute controls
    [u_t_alt, altitudeError] = FF_PID(controlParams.altitudeGains, altitudeError, t, altSetpointError);
    disp('pid loop');
    disp(controlParams.altitudeGains)
    
    % compute controls
    [u_t_yaw, yawError] = PID(controlParams.yawGains, yawError, t, yawSetpointError);
    disp('pid loop');
    disp(controlParams.yawGains)

    % publish
    stickCmdMsg = rosmessage('terpcopter_msgs/stickCmd');
    stickCmdMsg.Thrust = u_t_alt;%max(min(1,u_t_alt),-1);
    stickCmdMsg.Yaw = u_t_yaw;
    send(stickCmdPublisher, stickCmdMsg);
    fprintf('Published Stick Cmd., Thrust : %3.3f, Altitude : %3.3f, Altitude_SP : %3.3f, Error : %3.3f \n', stickCmdMsg.Thrust , stateEstimateMsg.Up, z_d, ( z - z_d ) );

    time = r.TotalElapsedTime;
	fprintf('Iteration: %d - Time Elapsed: %f\n',i,time)
	waitfor(r);
 end

