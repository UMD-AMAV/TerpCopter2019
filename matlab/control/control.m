%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Node: control
%
% Purpose:
% The purpose of the control node is to regulate the quadcopter to desired
% setpoints of [altitude, heading, forward speed, crab speed]. We refer to
% this as a 'ahsCmd' which is generated by a behavior in the autonomy node.
% The control node determines the appropriate 'stickCmd' [yaw, pitch, roll,
% thrust] to send to the virtual_transmitter.
%
% Input:
%   - ROS topic: /stateEstimate (generated by estimation)
%   - ROS topic: /ahsCmd (generated by autonomy)
%
% Output:
%   - ROS topic: /stickCmd (used by virtual_transmitter)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% prepare workspace
clear; close all; clc; format compact;
addpath('../')
params = loadParams();

global controlParams
controlParams = params.ctrl;
fprintf('Control Node Launching...\n');

% declare global variables
% Determine usage in other scripts - change to local if no other usage
global altitudeErrorHistory;
altitudeErrorHistory.lastVal = 0;
altitudeErrorHistory.lastSum = 0;
altitudeErrorHistory.lastTime = 0;
%
% yawError.lastVal = 0;
% yawError.lastSum = 0;
% yawError.lastTime = 0;


% initialize ROS
if(~robotics.ros.internal.Global.isNodeActive)
    rosinit;
end

% Subscribers
stateEstimateSubscriber = rossubscriber('/stateEstimate');
openLoopIsActiveSubscriber = rossubscriber('/openLoopIsActive', 'std_msgs/Bool');
closedLoopIsActiveSubscriber = rossubscriber('/closedLoopIsActive', 'std_msgs/Bool');
ahsCmdSubscriber = rossubscriber('/ahsCmd');
startMissionSubscriber = rossubscriber('/startMission', 'std_msgs/Bool');

yawSetpointSubscriber = rossubscriber('/yawSetpoint');

pidAltSettingSubscriber = rossubscriber('/pidAltSetting');
pidResetPublisher = rospublisher('/pidReset', 'std_msgs/Bool');
pidResetSubscriber = rossubscriber('/pidReset');

pidYawSettingSubscriber = rossubscriber('/pidYawSetting', 'terpcopter_msgs/ffpidSetting');

openLoopStickCmdSubscriber = rossubscriber('/openLoopStickCmd', 'terpcopter_msgs/openLoopStickCmd');


% Publishers
stickCmdPublisher = rospublisher('/stickCmd', 'terpcopter_msgs/stickCmd');

pause(2)
stickCmdMsg = rosmessage(stickCmdPublisher);
stickCmdMsg.Thrust = 0;
stickCmdMsg.Yaw = 0;

stateEstimateMsg = stateEstimateSubscriber.LatestMessage;

ahsCmdMsg = ahsCmdSubscriber.LatestMessage;

pidAltSettingMsg = pidAltSettingSubscriber.LatestMessage;
pidYawSettingMsg = pidYawSettingSubscriber.LatestMessage;

yawSetpointMsg = yawSetpointSubscriber.LatestMessage;

% timestamp
t0 = []; timeMatrix=[];
ti= rostime('now');
%abs_t = eval([int2str(ti.Sec) '.' ...
%int2str(ti.Nsec)]);

abs_t = double(ti.Sec)+double(ti.Nsec)*10^-9;

if isempty(t0), t0 = abs_t; end


altitudeErrorHistory.lastTime = 0; %stateEstimateMsg.Time;
display("alt meters")
display(ahsCmdMsg.AltitudeMeters)
%display("alt meters")
%display(altitudeErrorHistory.lastVal)
altitudeErrorHistory.lastVal = ahsCmdMsg.AltitudeMeters;
altitudeErrorHistory.lastSum = 0;
altitudeErrorHistory.lastError = 0;
u_t_alt = controlParams.altitudeGains.ffterm;



% absoluteYaw = stateEstimateMsg.Yaw;
absolutePitch = stateEstimateMsg.Pitch;
absoluteRoll = stateEstimateMsg.Roll;
Pitch_d = 0;
Roll_d = 0;

% ahsCmdMsg.HeadingRad = absoluteYaw;
% yawError.lastTime = stateEstimateMsg.Time;
% yawError.lastVal = 0; %ahsCmdMsg.HeadingRad;
% yawError.lastSum = 0;
u_t_yaw = 0;

disp('initialize loop');

r = robotics.Rate(10);
reset(r);

send(stickCmdPublisher, stickCmdMsg);

while(1)
    stateEstimateMsg = stateEstimateSubscriber.LatestMessage;
    ahsCmdMsg = ahsCmdSubscriber.LatestMessage;
    pidAltSettingMsg = pidAltSettingSubscriber.LatestMessage;
    pidYawSettingMsg = pidYawSettingSubscriber.LatestMessage;
    openLoopStickCmdMsg = openLoopStickCmdSubscriber.LatestMessage;
    openLoopIsActiveMsg = openLoopIsActiveSubscriber.LatestMessage;
    startMissionMsg = startMissionSubscriber.LatestMessage;
    closedLoopIsActiveMsg = closedLoopIsActiveSubscriber.LatestMessage;
    yawSetpointMsg = yawSetpointSubscriber.LatestMessage;
    
    
    if (openLoopIsActiveMsg.Data == true) & (closedLoopIsActiveMsg.Data == false)
        stickCmdMsg.Thrust = openLoopStickCmdMsg.Thrust;
        stickCmdMsg.Yaw = openLoopStickCmdMsg.Yaw;
        stickCmdMsg.Pitch = openLoopStickCmdMsg.Pitch;
        stickCmdMsg.Roll = openLoopStickCmdMsg.Roll;
    elseif (openLoopIsActiveMsg.Data == false) && (closedLoopIsActiveMsg.Data == true)
        
        % timestamp
        ti= rostime('now');
        abs_t = double(ti.Sec)+double(ti.Nsec)*10^-9;
        t = abs_t-t0;
        %timeMatrix = [timeMatrix;t];
        %if isempty(t0), t0 = abs_t; end
        
        %fprintf("t %6.4f",t);
        
        % unpack statestimate
        %t = stateEstimateMsg.Time;
        z = stateEstimateMsg.Range;
        yaw = stateEstimateMsg.Yaw; % - absoluteYaw;
        %fprintf('Current Quad Alttiude is : %3.3f m\n', z );
        
        % get setpoint
        z_d = ahsCmdMsg.AltitudeMeters;
        
        %%%% CAHNGING YAW FROM GUI TO VISION %%%%%
        yaw_d = yawSetpointMsg.Data; % ahsCmdMsg.HeadingRad;
        
        
        % update errors
        altError = z_d - z;
        
        % reset Integral
        pidResetMsg = rosmessage('std_msgs/Bool');
        pidResetMsg.Data = false;
        pidResetMsg = pidResetSubscriber.LatestMessage;
        if ~isempty(pidResetMsg)
            if pidResetMsg.Data == true
                disp("Resetting PID ...")
                altitudeErrorHistory.lastVal = ahsCmdMsg.AltitudeMeters;
                altitudeErrorHistory.lastSum = 0;
                pidResetMsg.Data = false;
                send(pidResetPublisher, pidResetMsg);
            end
        end
        
        % compute controls
        % FF_PID(gains, error, newTime, newErrVal)
        [u_t_alt, altitudeErrorHistory] = FF_PID(pidAltSettingMsg, altitudeErrorHistory, t, altError);
        disp('pid loop');
        disp(pidAltSettingMsg)
        %     disp('yawSetpoint')
        %     disp(yaw_d)
        disp('yawCurrent')
        disp(yaw)
        
        
%         New Yaw Controller
            %yaw_d = deg2rad(yaw_d);
            %yaw = deg2rad(yaw);
            yawError = yaw_d;%(yaw_d - yaw);
            yawError = (atan2(sin(yawError),cos(yawError)));
            disp('yawError')
              disp(yawError)
        
              disp('yawSetpointError')
%               disp(yaw_error)
        
            u_t_yaw = pidYawSettingMsg.Kp*yawError;
            
            
            %Pitch Control
            PitchError = Pitch_d - absolutePitch;
            u_t_pitch = -0.3*PitchError;
            
            %Roll COntrol
            RollError = Roll_d - absoluteRoll;
            u_t_roll = -0.3*RollError;
            
        % compute controls
        %      [u_t_yaw, yawError] = PID(pidYawSettingMsg, yawError, t, yaw_error);
        %      disp('yaw control gains');
        %      disp(controlParams.yawGains)
        %      disp('yaw control signal');
        %      disp(u_t_yaw)
        
        
        % publish
        stickCmdMsg.Thrust = max(min(2,u_t_alt),0)-1;
        stickCmdMsg.Yaw = max(-1,min(1,u_t_yaw));
        
        fprintf('Stick Cmd.Thrust : %3.3f, Altitude : %3.3f, Altitude_SP : %3.3f, Error : %3.3f, Yaw : %3.3f \n', stickCmdMsg.Thrust , stateEstimateMsg.Up, z_d, ( z - z_d ), u_t_yaw );
        
        time = r.TotalElapsedTime;
        %fprintf('Iteration: %d - Time Elapsed: %f\n',i,time)
%     elseif startMissionMsg.Data == false
%         fprintf('Mission has not started. Press Start Mission button in Tuner GUI.\n');
    else
        fprintf('Error: both open loop and closed loop control are either running or not running\n');
    end
    send(stickCmdPublisher, stickCmdMsg);
    disp('Controller');
    waitfor(r);
end

